<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Sam Stoelinga - Big Data</title><link href="https://samos-it.com/" rel="alternate"></link><link href="https://samos-it.com/feeds/big-data.atom.xml" rel="self"></link><id>https://samos-it.com/</id><updated>2020-09-13T20:01:23+02:00</updated><entry><title>Running Computer Vision algos on Spark with OpenCV</title><link href="https://samos-it.com/posts/computer-vision-opencv-sift-surf-kmeans-on-spark.html" rel="alternate"></link><published>2016-01-22T16:31:00+01:00</published><updated>2020-09-13T20:01:23+02:00</updated><author><name>Sam Stoelinga</name></author><id>tag:samos-it.com,2016-01-22:/posts/computer-vision-opencv-sift-surf-kmeans-on-spark.html</id><summary type="html">&lt;p&gt;This post shows several computer vision steps implemented on top of Spark.
OpenCV is used to extract features on top of OpenStack and Spark MLLib KMeans
is used to generate our KMeans dictionary. Then we use Spark and simple vector / matrix
manipulation to do coding and pooling.&lt;/p&gt;
&lt;p&gt;Workflow implemented using â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;This post shows several computer vision steps implemented on top of Spark.
OpenCV is used to extract features on top of OpenStack and Spark MLLib KMeans
is used to generate our KMeans dictionary. Then we use Spark and simple vector / matrix
manipulation to do coding and pooling.&lt;/p&gt;
&lt;p&gt;Workflow implemented using OpenCV and Spark:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Uploading our dataset of images to Hadoop compatible storage as Sequencefile&lt;/li&gt;
&lt;li&gt;Running OpenCV feature extraction(SURF, SIFT) code using the SequenceFile of images as input&lt;/li&gt;
&lt;li&gt;Running Spark default K-means model training machine learning code on extracted features&lt;/li&gt;
&lt;li&gt;Running Feature coding and pooling using our trained K-means model and extracted feature as input&lt;/li&gt;
&lt;li&gt;(TODO): Running machine learning algortihm to do classification on the encoded features&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Uploading image dataset as SequenceFile to Hadoop compatible storage (Swift)&lt;/h3&gt;
&lt;p&gt;In the first step we upload our Caltech256 dataset, 30k images totaling 1.2Gb, as SequenceFile to
OpenStack Swift. For this I've created a simplistic command line tool to upload folders containing
files to be stored as a SequenceFile with key=filename and value=raw_bytes. The tool has been
tested with HDFS and OpenStack Swift.&lt;/p&gt;
&lt;p&gt;The following commands show how to download Caltech-256 dataset consisting of JPG images.
Then upload the downloaded images to OpenStack Swift in sequence file format:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Download and compile the hadoop sequencefile upload tool&lt;/span&gt;
git&lt;span class="w"&gt; &lt;/span&gt;clone&lt;span class="w"&gt; &lt;/span&gt;https://github.com/samos123/hadoop-sequence-file-upload
&lt;span class="nb"&gt;cd&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;hadoop-sequence-file-upload
mvn&lt;span class="w"&gt; &lt;/span&gt;clean&lt;span class="w"&gt; &lt;/span&gt;compile&lt;span class="w"&gt; &lt;/span&gt;assembly:single
&lt;span class="c1"&gt;#  Download / extract calltech-256 dataset&lt;/span&gt;
axel&lt;span class="w"&gt; &lt;/span&gt;http://www.vision.caltech.edu/Image_Datasets/Caltech256/256_ObjectCategories.tar
tar&lt;span class="w"&gt; &lt;/span&gt;xf&lt;span class="w"&gt; &lt;/span&gt;256_ObjectCategories.tar
&lt;span class="c1"&gt;# Upload to Swift, this assumes /etc/hadoop/conf/core-site.xml is used to store Swift details&lt;/span&gt;
./upload-to-sequence-file.sh&lt;span class="w"&gt; &lt;/span&gt;256_ObjectCategories/&lt;span class="w"&gt; &lt;/span&gt;swift://spark.swift1/caltech-256.hseq
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The dataset is also accessible through Tachyon as we configured it to use Swift as underFS.&lt;/p&gt;
&lt;h3&gt;Extract SIFT/SURF features using OpenCV on Spark&lt;/h3&gt;
&lt;p&gt;I've created a simple Spark application that uses OpenCV
to extract SURF or SIFT features from an image.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;__future__&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;print_function&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;logging&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;io&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;cv2&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;np&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pyspark&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;SparkContext&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pyspark.sql&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;SQLContext&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Row&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;extract_opencv_features&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;feature_name&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;extract_opencv_features_nested&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;imgfile_imgbytes&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;imgfilename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;imgbytes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;imgfile_imgbytes&lt;/span&gt;
            &lt;span class="n"&gt;nparr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fromstring&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;imgbytes&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;uint8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;img&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cv2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;imdecode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nparr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;feature_name&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;surf&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;SURF&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
                &lt;span class="n"&gt;extractor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cv2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SURF&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;feature_name&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;sift&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;SIFT&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
                &lt;span class="n"&gt;extractor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cv2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SIFT&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

            &lt;span class="n"&gt;kp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;descriptors&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;extractor&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;detectAndCompute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;imgfilename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;descriptors&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
        &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;Exception&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exception&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;extract_opencv_features_nested&lt;/span&gt;


&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;sc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SparkContext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;appName&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;feature_extractor&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;sqlContext&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SQLContext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;feature_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="n"&gt;image_seqfile_path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="n"&gt;feature_parquet_path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="n"&gt;partitions&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="k"&gt;except&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Usage: spark-submit feature_extraction.py &amp;lt;feature_name(sift or surf)&amp;gt; &amp;quot;&lt;/span&gt;
              &lt;span class="s2"&gt;&amp;quot;&amp;lt;image_sequencefile_input_path&amp;gt; &amp;lt;feature_sequencefile_output_path&amp;gt; &amp;lt;partitions&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;images&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sequenceFile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;image_seqfile_path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;minSplits&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;partitions&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;features&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;images&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flatMap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;extract_opencv_features&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;feature_name&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;features&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;features&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;features&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;features&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Row&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fileName&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;features&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tolist&lt;/span&gt;&lt;span class="p"&gt;())))&lt;/span&gt;
    &lt;span class="n"&gt;featuresSchema&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sqlContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;createDataFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;features&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;featuresSchema&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;registerTempTable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;images&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;featuresSchema&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parquet&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;feature_parquet_path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Using the above Spark application we can start to extract features from our image dataset in Swift.
As input we provide the sequencefile containing &lt;code&gt;&amp;lt;fileName: String, image: Bytes&amp;gt;&lt;/code&gt;. The extracted
features we write out as parquet file. The following command extracts the sift features from our dataset:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;spark-submit&lt;span class="w"&gt; &lt;/span&gt;--executor-memory&lt;span class="w"&gt; &lt;/span&gt;8g&lt;span class="w"&gt; &lt;/span&gt;feature_extraction.py&lt;span class="w"&gt; &lt;/span&gt;sift&lt;span class="w"&gt; &lt;/span&gt;swift://spark.swift1/caltech-256.hseq&lt;span class="w"&gt; &lt;/span&gt;swift://spark.swift1/caltech-256-sift1.parquet&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;100&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;K-Means Dictionary generation on SIFT features&lt;/h3&gt;
&lt;p&gt;We can now generate our dictionary of features through Spark's MLLib KMeans algorithm.
The below application is used to train our KMeans model using the features generated in the
previous step as input dataset.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;__future__&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;print_function&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;io&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;np&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pyspark&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;SparkContext&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pyspark.mllib.clustering&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;KMeans&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pyspark.sql&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;SQLContext&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Row&lt;/span&gt;


&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;sc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SparkContext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;appName&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;kmeans_dictionary_creation&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;sqlContext&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SQLContext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
        &lt;span class="n"&gt;feature_parquet_path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="n"&gt;kmeans_model_path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;except&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Usage: spark-submit kmeans.py &amp;lt;k:clusters&amp;gt; &amp;quot;&lt;/span&gt;
              &lt;span class="s2"&gt;&amp;quot;&amp;lt;feature_sequencefile_input_path&amp;gt; &amp;lt;kmeans_model_output&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;features&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sqlContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parquet&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;feature_parquet_path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;# Create same size vectors of the feature descriptors&lt;/span&gt;
    &lt;span class="c1"&gt;# flatMap returns every list item as a new row for the RDD&lt;/span&gt;
    &lt;span class="c1"&gt;# hence transforming x, 128 to x rows of 1, 128 in the RDD.&lt;/span&gt;
    &lt;span class="c1"&gt;# This is needed for KMeans.&lt;/span&gt;
    &lt;span class="n"&gt;features&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;features&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flatMap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;features&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cache&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;KMeans&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;train&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;features&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;maxIterations&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;initializationMode&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;random&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;save&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;kmeans_model_path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Clusters have been saved as text file to &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;kmeans_model_path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Final centers: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clusterCenters&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;sc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Start the spark job with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;spark-submit&lt;span class="w"&gt; &lt;/span&gt;--executor-memory&lt;span class="w"&gt; &lt;/span&gt;8g&lt;span class="w"&gt; &lt;/span&gt;kmeans.py&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1000&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;swift://spark.swift1/caltech-256-sift1.parquet&lt;span class="w"&gt; &lt;/span&gt;swift://spark.swift1/caltech-256-dictionary
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Feature coding and pooling with trained KMeans model&lt;/h3&gt;
&lt;p&gt;In this step we will use the KMeans dictionary that we trained
in the previous step to encode each point of interest to a single cluster.
This is done by assigning every row of our x * 128 matrix to a single cluster
of the KMeans dictionary. The result is a 1 * k representation for each image
utilizing coding and pooling. For pooling we've implemented a simple max and sum pooling method.&lt;/p&gt;
&lt;p&gt;The following Spark application implements feature coding and pooling:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;__future__&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;print_function&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;functools&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;io&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;np&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;scipy.spatial&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pyspark.mllib.clustering&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;KMeansModel&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pyspark&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;SparkContext&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pyspark.sql&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;SQLContext&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Row&lt;/span&gt;

&lt;span class="n"&gt;SUPPORTED_POOLING&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;max&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;sum&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;assign_pooling&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;clusterCenters&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pooling&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;image_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;fileName&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;feature_matrix&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;features&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="n"&gt;clusterCenters&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;clusterCenters&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;
    &lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;KMeansModel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clusterCenters&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;bow&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zeros&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clusterCenters&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;feature_matrix&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;predict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;dist&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;euclidean&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clusterCenters&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;pooling&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;max&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;bow&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bow&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;dist&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;pooling&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;sum&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;bow&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bow&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;dist&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Row&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fileName&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;image_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;bow&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;bow&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tolist&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;


&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;sc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SparkContext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;appName&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;kmeans_assign&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;sqlContext&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SQLContext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;feature_parquet_path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="n"&gt;kmeans_model_path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="n"&gt;bow_parquet_path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="n"&gt;pooling&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="k"&gt;except&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Usage: spark-submit feature_coding_pooling.py &amp;quot;&lt;/span&gt;
              &lt;span class="s2"&gt;&amp;quot;&amp;lt;feature_sequencefile_path&amp;gt; &amp;lt;kmeans_model&amp;gt; &amp;quot;&lt;/span&gt;
              &lt;span class="s2"&gt;&amp;quot;&amp;lt;bow_sequencefile_path&amp;gt; &amp;lt;pooling_method:max&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;pooling&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;SUPPORTED_POOLING&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;ValueError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Pooling method &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s2"&gt; is not supported. Supported poolings methods: &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pooling&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SUPPORTED_POOLING&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="n"&gt;features&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sqlContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parquet&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;feature_parquet_path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;KMeansModel&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;load&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;kmeans_model_path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;clusterCenters&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clusterCenters&lt;/span&gt;
    &lt;span class="n"&gt;clusterCenters&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;broadcast&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clusterCenters&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;features_bow&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;features&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;functools&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;partial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;assign_pooling&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;clusterCenters&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;clusterCenters&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pooling&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;pooling&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;featuresSchema&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sqlContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;createDataFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;features_bow&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;featuresSchema&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;registerTempTable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;images&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;featuresSchema&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parquet&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bow_parquet_path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;sc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Execute the spark applicaiton with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;spark-submit&lt;span class="w"&gt; &lt;/span&gt;--executor-memory&lt;span class="w"&gt; &lt;/span&gt;8g&lt;span class="w"&gt; &lt;/span&gt;feature_coding_pooling.py&lt;span class="w"&gt; &lt;/span&gt;swift://spark.swift1/caltech-256-sift1.parquet&lt;span class="w"&gt; &lt;/span&gt;swift://spark.swift1/caltech-256-dictionary&lt;span class="w"&gt; &lt;/span&gt;swift://spark.swift1/caltech-256-bow.parquet&lt;span class="w"&gt; &lt;/span&gt;sum
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="Big Data"></category><category term="opencv"></category><category term="spark"></category><category term="tachyon"></category><category term="swift"></category><category term="hadoop"></category><category term="openstack"></category><category term="big data"></category></entry><entry><title>Elastic Data Processing on OpenStack with Spark, Tachyon and Swift</title><link href="https://samos-it.com/posts/spark-tachyon-swift-openstack-mesos-elastic-data-processing.html" rel="alternate"></link><published>2015-11-09T16:31:00+01:00</published><updated>2020-09-13T20:01:23+02:00</updated><author><name>Sam Stoelinga</name></author><id>tag:samos-it.com,2015-11-09:/posts/spark-tachyon-swift-openstack-mesos-elastic-data-processing.html</id><summary type="html">&lt;p&gt;This post will describe how to configure, build and deploy
Spark with Tachyon and Swift as storage. This architecture
is meant to be more suitable for running Big Data workloads
on top of the cloud such as OpenStack.&lt;/p&gt;
&lt;p&gt;Using Swift as storage layer for Spark gives us the ability
to â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;This post will describe how to configure, build and deploy
Spark with Tachyon and Swift as storage. This architecture
is meant to be more suitable for running Big Data workloads
on top of the cloud such as OpenStack.&lt;/p&gt;
&lt;p&gt;Using Swift as storage layer for Spark gives us the ability
to utilize the cloud paradigm with Big Data. We can now
on demand spin up n-amount of VMs, run a spark job with input
data from Swift, then when finished store the result back in Swift and
finally when the job is finished, destroy the VMs. This kind of elastic
data processing, using Tachyon for fast localized in-memory storage gives you high
performance and also elasticity of the cloud.&lt;/p&gt;
&lt;p&gt;The general architecture looks like this:
&lt;img alt="Big Data Cloud Architecture" src="/images/big-data-cloud-architecture.png"&gt;&lt;/p&gt;
&lt;p&gt;Assumptions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You have a working Mesos cluster that can run Spark
  jobs&lt;/li&gt;
&lt;li&gt;We have two nodes: mesos-master-1 (192.168.111.54) and
  mesos-slave-1 (192.168.111.57). We will run tachyon master
  on the mesos-master-1 node and tachyon worker on mesos-slave-1&lt;/li&gt;
&lt;li&gt;OpenStack Keystone and Swift are available at 10.10.10.10&lt;/li&gt;
&lt;li&gt;Tachyon 0.8.0 is deployed and configured to use Swift as
  underfs&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The general workflow of this post is:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Installation of Tachyon 0.8.0 with Swift as underFS on the mesos-slaves&lt;/li&gt;
&lt;li&gt;Building Spark 1.6.0-SNAPSHOT from latest master branch with Tachyon 0.8.0
   and tachyon-underfs-swift as dependencies.&lt;/li&gt;
&lt;li&gt;Running an example Spark job which uses Tachyon for input
   and output.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Tachyon 0.8.0 installation with Swift as underFS&lt;/h2&gt;
&lt;p&gt;Download and extract Tachyon to the mesos-master and mesos-slave&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;wget&lt;span class="w"&gt; &lt;/span&gt;http://tachyon-project.org/downloads/files/0.8.0/tachyon-0.8.0-hadoop2.6-bin.tar.gz
scp&lt;span class="w"&gt; &lt;/span&gt;tachyon-0.8.0-hadoop2.6-bin.tar.gz&lt;span class="w"&gt; &lt;/span&gt;mesos-master-1:/srv/
scp&lt;span class="w"&gt; &lt;/span&gt;tachyon-0.8.0-hadoop2.6-bin.tar.gz&lt;span class="w"&gt; &lt;/span&gt;mesos-slave-1:/srv/
ssh&lt;span class="w"&gt; &lt;/span&gt;mesos-master-1&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;cd /srv/ &amp;amp;&amp;amp; tar xzf tachyon-0.8.0-hadoop2.6-bin.tar.gz&amp;quot;&lt;/span&gt;
ssh&lt;span class="w"&gt; &lt;/span&gt;mesos-slave-1&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;cd /srv/ &amp;amp;&amp;amp; tar xzf tachyon-0.8.0-hadoop2.6-bin.tar.gz&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;On both mesos-master-1 and mesos-slave-1, copy /srv/tachyon-0.8.0/conf/tachyon-env.sh.swift
to /srv/tachyon-0.8.0/conf/tachyon-env.sh&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;mv&lt;span class="w"&gt; &lt;/span&gt;/srv/tachyon-0.8.0/conf/tachyon-env.sh&lt;span class="o"&gt;{&lt;/span&gt;.swift,&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Make minor modifications to /srv/tachyon-0.8.0/conf/tachyon-env.sh on both mesos-master-1 and
mesos-slave-1:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nb"&gt;export&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;TACHYON_MASTER_ADDRESS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;192&lt;/span&gt;.168.111.54
&lt;span class="nb"&gt;export&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;TACHYON_UNDERFS_ADDRESS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;swift://spark.swift1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The TACHYON_MASTER_ADDRESS is set to the use the external IP
of the mesos-master node. The variable TACHYON_UNDERFS_ADDRESS
is set to swift://spark.swift1 where spark is the name of the
Swift container and swift1 is an arbitary name to specify
an Swift connection object defined in tachyon/conf/core-site.xml.&lt;/p&gt;
&lt;p&gt;Now in core-site.xml we need to define how to connect to Swift.
This is done by changing settings for swift1 provider in
core-site.xml. I'm using Keystone
to authenticate with Swift and also to retreive the
correct endpoint.&lt;/p&gt;
&lt;p&gt;I've changed core-site.xml according to my Swift environment and
copied it to tachyon/conf/core-site.xml. The following changes were made:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;property&amp;gt;
&lt;span class="w"&gt; &lt;/span&gt;&amp;lt;name&amp;gt;fs.swift.service.swift1.location-aware&amp;lt;/name&amp;gt;
&lt;span class="w"&gt; &lt;/span&gt;&amp;lt;value&amp;gt;false&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
&lt;span class="w"&gt;  &lt;/span&gt;&amp;lt;name&amp;gt;fs.swift.service.swift1.auth.url&amp;lt;/name&amp;gt;
&lt;span class="w"&gt;  &lt;/span&gt;&amp;lt;value&amp;gt;http://10.10.10.10:5000/v2.0/tokens&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
&lt;span class="w"&gt;  &lt;/span&gt;&amp;lt;name&amp;gt;fs.swift.service.swift1.http.port&amp;lt;/name&amp;gt;
&lt;span class="w"&gt;  &lt;/span&gt;&amp;lt;value&amp;gt;8080&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
&lt;span class="w"&gt;  &lt;/span&gt;&amp;lt;name&amp;gt;fs.swift.service.swift1.region&amp;lt;/name&amp;gt;
&lt;span class="w"&gt;  &lt;/span&gt;&amp;lt;value&amp;gt;RegionOne&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
&lt;span class="w"&gt;  &lt;/span&gt;&amp;lt;name&amp;gt;fs.swift.service.swift1.public&amp;lt;/name&amp;gt;
&lt;span class="w"&gt;  &lt;/span&gt;&amp;lt;value&amp;gt;true&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
&lt;span class="w"&gt;  &lt;/span&gt;&amp;lt;name&amp;gt;fs.swift.service.swift1.auth.endpoint.prefix&amp;lt;/name&amp;gt;
&lt;span class="w"&gt;  &lt;/span&gt;&amp;lt;value&amp;gt;endpoints&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
&lt;span class="w"&gt;  &lt;/span&gt;&amp;lt;name&amp;gt;fs.swift.service.swift1.tenant&amp;lt;/name&amp;gt;
&lt;span class="w"&gt;  &lt;/span&gt;&amp;lt;value&amp;gt;spark&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
&lt;span class="w"&gt;  &lt;/span&gt;&amp;lt;name&amp;gt;fs.swift.service.swift1.password&amp;lt;/name&amp;gt;
&lt;span class="w"&gt;  &lt;/span&gt;&amp;lt;value&amp;gt;test123&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
&lt;span class="w"&gt;  &lt;/span&gt;&amp;lt;name&amp;gt;fs.swift.service.swift1.username&amp;lt;/name&amp;gt;
&lt;span class="w"&gt;  &lt;/span&gt;&amp;lt;value&amp;gt;spark&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;After all config changes are done we can start launching
the Tachyon master process on the mesos-master-1 node.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/srv/tachyon-0.8.0/bin/tachyon-start.sh&lt;span class="w"&gt; &lt;/span&gt;master&lt;span class="w"&gt; &lt;/span&gt;-f
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;After successful start of the tachyon master, also start the tachyon worker
on mesos-slave-1:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/srv/tachyon-0.8.0/bin/tachyon-start.sh&lt;span class="w"&gt; &lt;/span&gt;worker&lt;span class="w"&gt; &lt;/span&gt;SudoMount
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;You should now have Tachyon running and you can access it via
http://192.168.111.54:19999&lt;/p&gt;
&lt;h2&gt;Building Spark with Tachyon 0.8.0 and Swift&lt;/h2&gt;
&lt;p&gt;Checkout latest master branch of spark:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;git&lt;span class="w"&gt; &lt;/span&gt;clone&lt;span class="w"&gt; &lt;/span&gt;https://github.com/apache/spark.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Apply the following patches to core/pom.xml and make_distribution.sh
to use tachyon 0.8.0 and to include hdfs as underfs dependency.
Make sure to exclude mockito-all else the build will fail with&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="gh"&gt;diff --git a/core/pom.xml b/core/pom.xml&lt;/span&gt;
&lt;span class="gh"&gt;index 570a25c..98285a0 100644&lt;/span&gt;
&lt;span class="gd"&gt;--- a/core/pom.xml&lt;/span&gt;
&lt;span class="gi"&gt;+++ b/core/pom.xml&lt;/span&gt;
&lt;span class="gu"&gt;@@ -262,7 +262,7 @@&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;    &amp;lt;dependency&amp;gt;
&lt;span class="w"&gt; &lt;/span&gt;      &amp;lt;groupId&amp;gt;org.tachyonproject&amp;lt;/groupId&amp;gt;
&lt;span class="w"&gt; &lt;/span&gt;      &amp;lt;artifactId&amp;gt;tachyon-client&amp;lt;/artifactId&amp;gt;
&lt;span class="gd"&gt;-      &amp;lt;version&amp;gt;0.8.1&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;span class="gi"&gt;+      &amp;lt;version&amp;gt;0.8.0&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;      &amp;lt;exclusions&amp;gt;
&lt;span class="w"&gt; &lt;/span&gt;        &amp;lt;exclusion&amp;gt;
&lt;span class="w"&gt; &lt;/span&gt;          &amp;lt;groupId&amp;gt;org.apache.hadoop&amp;lt;/groupId&amp;gt;
&lt;span class="gu"&gt;@@ -287,6 +287,17 @@&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;      &amp;lt;/exclusions&amp;gt;
&lt;span class="w"&gt; &lt;/span&gt;    &amp;lt;/dependency&amp;gt;
&lt;span class="w"&gt; &lt;/span&gt;    &amp;lt;dependency&amp;gt;
&lt;span class="gi"&gt;+      &amp;lt;groupId&amp;gt;org.tachyonproject&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;span class="gi"&gt;+      &amp;lt;artifactId&amp;gt;tachyon-underfs-swift&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;span class="gi"&gt;+      &amp;lt;version&amp;gt;0.8.0&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;span class="gi"&gt;+      &amp;lt;exclusions&amp;gt;&lt;/span&gt;
&lt;span class="gi"&gt;+        &amp;lt;exclusion&amp;gt;&lt;/span&gt;
&lt;span class="gi"&gt;+          &amp;lt;groupId&amp;gt;org.mockito&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;span class="gi"&gt;+          &amp;lt;artifactId&amp;gt;mockito-all&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;span class="gi"&gt;+        &amp;lt;/exclusion&amp;gt;&lt;/span&gt;
&lt;span class="gi"&gt;+      &amp;lt;/exclusions&amp;gt;&lt;/span&gt;
&lt;span class="gi"&gt;+    &amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;span class="gi"&gt;+    &amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;      &amp;lt;groupId&amp;gt;org.seleniumhq.selenium&amp;lt;/groupId&amp;gt;
&lt;span class="w"&gt; &lt;/span&gt;      &amp;lt;artifactId&amp;gt;selenium-java&amp;lt;/artifactId&amp;gt;
&lt;span class="w"&gt; &lt;/span&gt;      &amp;lt;exclusions&amp;gt;

&lt;span class="gh"&gt;diff --git a/make-distribution.sh b/make-distribution.sh&lt;/span&gt;
&lt;span class="gh"&gt;index e1c2afd..f676678 100755&lt;/span&gt;
&lt;span class="gd"&gt;--- a/make-distribution.sh&lt;/span&gt;
&lt;span class="gi"&gt;+++ b/make-distribution.sh&lt;/span&gt;
&lt;span class="gu"&gt;@@ -33,7 +33,7 @@ SPARK_HOME=&amp;quot;$(cd &amp;quot;`dirname &amp;quot;$0&amp;quot;`&amp;quot;; pwd)&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;DISTDIR=&amp;quot;$SPARK_HOME/dist&amp;quot;

&lt;span class="w"&gt; &lt;/span&gt;SPARK_TACHYON=false
&lt;span class="gd"&gt;-TACHYON_VERSION=&amp;quot;0.8.1&amp;quot;&lt;/span&gt;
&lt;span class="gi"&gt;+TACHYON_VERSION=&amp;quot;0.8.0&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;TACHYON_TGZ=&amp;quot;tachyon-${TACHYON_VERSION}-bin.tar.gz&amp;quot;
&lt;span class="w"&gt; &lt;/span&gt;TACHYON_URL=&amp;quot;http://tachyon-project.org/downloads/files/${TACHYON_VERSION}/${TACHYON_TGZ}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Build Spark with Tachyon and Swift as underfs:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;./make-distribution.sh&lt;span class="w"&gt; &lt;/span&gt;--name&lt;span class="w"&gt; &lt;/span&gt;spark-master-tachyon-0.8.0&lt;span class="w"&gt; &lt;/span&gt;--tgz&lt;span class="w"&gt; &lt;/span&gt;--with-tachyon&lt;span class="w"&gt; &lt;/span&gt;-Pyarn&lt;span class="w"&gt; &lt;/span&gt;-Phadoop-2.6&lt;span class="w"&gt; &lt;/span&gt;-Dhadoop.version&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;.6.0&lt;span class="w"&gt; &lt;/span&gt;-DskipTests
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Add core-site.xml which we used in Tachyon to the Spark tarball. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;tar&lt;span class="w"&gt; &lt;/span&gt;xzf&lt;span class="w"&gt; &lt;/span&gt;spark-1.6.0-SNAPSHOT-bin-spark-master-tachyon-0.8.0.tgz
cp&lt;span class="w"&gt; &lt;/span&gt;/srv/tachyon-0.8.0/conf/core-site.xml&lt;span class="w"&gt; &lt;/span&gt;spark-1.6.0*/conf/core-site.xml
tar&lt;span class="w"&gt; &lt;/span&gt;czf&lt;span class="w"&gt; &lt;/span&gt;spark-1.6.0.tar.gz&lt;span class="w"&gt; &lt;/span&gt;spark-1.6.0-SNAPSHOT-bin-spark-master-tachyon-0.8.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;For some reason Spark also needs core-site.xml with the Swift connection settings
even though we already configured this in Tachyon.&lt;/p&gt;
&lt;h2&gt;Running a Spark job with Tachyon as input backed by Swift&lt;/h2&gt;
&lt;p&gt;Assuming that in our Swift container we have an object called
output.log we can now create a Spark shell session and use&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;spark-shell
val&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;textFile&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;sc.textFile&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;tachyon://mesos-master-1:19998/output.log&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
textFile.count&lt;span class="o"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;I've also verified that I could successfuly use sequenceFiles and Spark pickleFiles on
Tachyon with Swift by running the Python spark jobs of my other project: 
&lt;a href="https://github.com/samos123/computer-vision-cloud-platform"&gt;Spark Computer vision&lt;/a&gt;&lt;/p&gt;</content><category term="Big Data"></category><category term="spark"></category><category term="tachyon"></category><category term="swift"></category><category term="hadoop"></category><category term="openstack"></category><category term="big data"></category></entry></feed>